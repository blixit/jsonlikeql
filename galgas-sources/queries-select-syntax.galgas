
#------------------------------------------------------------
#	S E M A N T I Q U E   -   C L A S S
#------------------------------------------------------------

#------------------------------------------------------------
#	S Y N T A X
#------------------------------------------------------------

syntax extension jsonlikeql_syntax {


#	S E L E C T     Q U E R I E S
#------------------------------------------------------------
rule <query> 
	? @lchar queryType
	?! @Query query
	? @FunctionsMap functionsMap
	{ 
	$identifier$ ?let @lstring name 

	# détection des paramètres

	@ObjectLV parameters = .default;
	select or
	<function_parameters> !? parameters
	end 

	# détection de la propagation : seulement pour les fonctions de type select

	@Propagation propagation = @Propagation.default_;
	select or
	<propagation> !? propagation
	end

	# détection des champs de la requete

	@QueryMap fieldsQ = .default; 

	select or
		<fields> !queryType !?fieldsQ !functionsMap
	end

	@lstring returnedType = .default
	getFunctionReturnedType( !name !functionsMap !? returnedType);

	query = @SelectQuery.new{ !name !@lchar.new{!queryType !@location.here}  !parameters !returnedType !fieldsQ !propagation }

}

rule <fields> 
	? @lchar queryType
	?! @QueryMap fieldsQ 
	? @FunctionsMap functionsMap
	{
	
	${$ 
	select or
		repeat
			@Query query = @Query.default; 
			<field> !queryType !?query !functionsMap

			if( [[[query name] string] length] > 0 ) then 
				[!? fieldsQ insertKey ![query name] !query]
		 		 
	 		end
		while
		$,$
		end
	end
	$}$ 
}

rule <field> 
	? @lchar queryType
	?! @Query query 
	? @FunctionsMap functionsMap
	{
	$identifier$ ?let @lstring name

	@ObjectLV parameters = .default;	
	@Propagation propagation = @Propagation.default_;
	@QueryMap fieldsQ = .default; 

	select 

	or	  
		# détection des paramètres
		select or				
			<function_parameters> !?parameters
		end 
		
		# détection de la propagation : seulement pour les fonctions de type select
		select or
			<propagation> !? propagation
		end
		
		<fields> !queryType !?fieldsQ !functionsMap
 
	end

	#####
	# lorsque je ferai la semantique dynamique de cette requete, je regarderai comment on gère le type retourné
	#####

	@lstring returnedType  =  .default

	query = @SelectQuery.new{ !name !@lchar.new{!queryType !@location.here}  !parameters !returnedType !fieldsQ !propagation }

}

rule <propagation> 
	?! @Propagation propagation
	{

	$propagate$ 
	select 
		$default$
		propagation = @Propagation.default_
	or
		$full$
		propagation = @Propagation.full_
	end	
}

}

#------------------------------------------------------------
#	S E M A N T I Q U E   -   F U N C T I O N S
#------------------------------------------------------------

override method @SelectQuery toSql 
	?!@string sql
	{ 

	@LocalError erreur = {};
	@string ErrorifArgsRequired = "If-args-required";
	@string ErrorifArgRequiresStringValue = "If-Arg-Requires-String-Value";
	[!? erreur insertKey !.new{!ErrorifArgsRequired !@location.here}]
	[!? erreur insertKey !.new{!ErrorifArgRequiresStringValue !@location.here}]

	sql = "";
	sql += "/* Requete SELECT `"+name.string +"` */\n";

	@string table = ""; 

	#log fields

	[self getMainTable !? table ]

	sql += "SELECT ";

	@string fieldsStr = ""; 
	@uint count = [fields count];
	@uint i = 0;

	if( count > 0 ) then 
		for () in fields do 
			fieldsStr += [[query name] string] 

			if( i < count -1) then 
				fieldsStr += ", "; 
			end
			i++;
		end
		sql += fieldsStr + " ";
	else
		sql += "* ";
	end

	

	sql += "FROM ";

	sql += "`"+ table +"` " ;

	# les conditions et autres directives sql
	# ---------------------------------------------------
	@string conditions = .default
	[self getIfParameterToString !?conditions ![parameters mLvalue] !ErrorifArgRequiresStringValue !erreur ] 

	if ([conditions length] > 0) then
		sql += "WHERE "+conditions+" "
	end


	sql += ";\n";
}

#------------------------------------------------------------
#	S E M A N T I Q U E   -   C L A S S
#------------------------------------------------------------

#------------------------------------------------------------
#	S Y N T A X
#------------------------------------------------------------

syntax extension jsonlikeql_syntax {


#	S E L E C T     Q U E R I E S
#------------------------------------------------------------
rule <query> 
	? @lchar queryType
	?! @Query query
	? @FunctionsMap functionsMap
	{ 
	$identifier$ ?let @lstring name 

	# détection des paramètres

	@ObjectLV parameters = .default;
	select or
	<function_parameters> !? parameters
	end 

	# détection de la propagation : seulement pour les fonctions de type select

	@Propagation propagation = @Propagation.default_;
	select or
	<propagation> !? propagation
	end

	# détection des champs de la requete

	@QueryMap fieldsQ = .default; 

	select or
		<fields> !queryType !?fieldsQ !functionsMap
	end

	@lstring returnedType = .default
	getFunctionReturnedType( !name !functionsMap !? returnedType);

	query = @SelectQuery.new{ !name !@lchar.new{!queryType !@location.here}  !parameters !returnedType !fieldsQ !propagation }

}

rule <fields> 
	? @lchar queryType
	?! @QueryMap fieldsQ 
	? @FunctionsMap functionsMap
	{
	
	${$ 
	select or
		repeat
			@Query query = @Query.default; 
			<field> !queryType !?query !functionsMap

			if( [[[query name] string] length] > 0 ) then 
				[!? fieldsQ insertKey ![query name] !query]
		 		 
	 		end
		while
		$,$
		end
	end
	$}$ 
}

rule <field> 
	? @lchar queryType
	?! @Query query 
	? @FunctionsMap functionsMap
	{
	$identifier$ ?let @lstring name

	@ObjectLV parameters = .default;	
	@Propagation propagation = @Propagation.default_;
	@QueryMap fieldsQ = .default; 

	select 

	or	  
		# détection des paramètres
		select or				
			<function_parameters> !?parameters
		end 
		
		# détection de la propagation : seulement pour les fonctions de type select
		select or
			<propagation> !? propagation
		end
		
		<fields> !queryType !?fieldsQ !functionsMap
 
	end

	#####
	# lorsque je ferai la semantique dynamique de cette requete, je regarderai comment on gère le type retourné
	#####

	@lstring returnedType  =  .default

	query = @SelectQuery.new{ !name !@lchar.new{!queryType !@location.here}  !parameters !returnedType !fieldsQ !propagation }

}

rule <propagation> 
	?! @Propagation propagation
	{

	$propagate$ 
	select 
		$default$
		propagation = @Propagation.default_
	or
		$full$
		propagation = @Propagation.full_
	end	
}

}

#------------------------------------------------------------
#	S E M A N T I Q U E   -   F U N C T I O N S
#------------------------------------------------------------

override method @SelectQuery toSql 
	?!@string sql
	{ 

	@LocalError erreur = {};
	@string ErrorifArgsRequired = "If-args-required";
	[!? erreur insertKey !.new{!ErrorifArgsRequired !@location.here}]

	sql = "";
	sql += "/* Requete SELECT `"+name.string +"` */\n";

	@string table = ""; 

	#log fields

	[self getMainTable !? table ]

	sql += "SELECT ";

	@string fieldsStr = ""; 
	@uint count = [fields count];
	@uint i = 0;

	if( count > 0 ) then 
		for () in fields do 
			fieldsStr += [[query name] string] 

			if( i < count -1) then 
				fieldsStr += ", "; 
			end
			i++;
		end
		sql += fieldsStr + " ";
	else
		sql += "* ";
	end

	

	sql += "FROM ";

	sql += "`"+ table +"` " ;

	# les conditions et autres directives sql
	# ---------------------------------------------------

	@MemberList mlist = [parameters mLvalue]
 
	#si des paramètres ont été fournis
	@uint argsCount = [mlist length]
	if(argsCount > 0) then  
		for member in mlist do 
			if ( [[member mMember] mKey] == "if" ) then 
				############@LValue conditions = [[member mMember ] mValue]				 
				@LValueList conditions = {};
				[[[member mMember ] mValue] getArray !?conditions]
				@string conditionsStr = "";
				@uint nbCond = [conditions length]
				@uint it = 0;

				if( nbCond == 0) then 
					[!? erreur insertKey !.new{!ErrorifArgsRequired !@location.here}]
				end
				
				for c in conditions do
					@string cstr = ""
					[[c mItem] getString !?cstr] 
					conditionsStr += cstr+ " "
					if (it < nbCond -1 ) then 
						conditionsStr += " "
					end
					it++ 
				end
				sql += "WHERE "+conditionsStr+" "
			end
		end
		#
	end

	sql += ";\n";
}
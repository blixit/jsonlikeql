
#------------------------------------------------------------
#	S E M A N T I Q U E   -   C L A S S
#------------------------------------------------------------


# 	L V A L U E
# ------------------------------------------------------------

class @LValue{
	@location here;
}
	method @LValue getArray
		?!@LValueList value
		{ value = .default ; }
	method @LValue getInteger
		?!@uint value
		{ value = .default ; }
	method @LValue getDouble
		?!@double value
		{ value = .default ; }
	method @LValue getString
		?!@string value
		{ value = .default ; }
	method @LValue getChar
		?!@char value
		{ value = .default ; }
	method @LValue getBool
		?!@bool value
		{ value = .default ; }

class @IntegerLV : @LValue{
	@uint mLvalue;
}
	override method @IntegerLV getInteger
		?!@uint value
		{value = mLvalue}
class @DoubleLV : @LValue{
	@double mLvalue;
}
	override method @DoubleLV getDouble
		?!@double value
		{value = mLvalue}
class @CharLV : @LValue{
	@char mLvalue;
}
	override method @CharLV getChar
		?!@char value
		{value = mLvalue}
class @StringLV : @LValue{
	@string mLvalue;
}
	override method @StringLV getString
		?!@string value
		{value = mLvalue}
class @BoolLV : @LValue{
	@bool mLvalue;
}
	override method @BoolLV getBool
		?!@bool value
		{value = mLvalue}
class @ObjectLV : @LValue{	
	@MemberList mLvalue;
}
class @ArrayLV : @LValue{	
	@LValueList mLvalue;
} 
	override method @ArrayLV getArray
		?!@LValueList value
		{value = mLvalue}

class @Member{
	@string mKey;
	@LValue mValue;
}

list @MemberList {
	@Member mMember;
}

list @LValueList {
	@LValue mItem;
}

#------------------------------------------------------------
#	S Y N T A X
#------------------------------------------------------------

syntax extension jsonlikeql_syntax {

rule <bool_definition> ?!@lbool b{
	select 
		$true$ 
		b = @lbool.new{!true !@location.here} 
	or
		$false$ 
		b = @lbool.new{!false !@location.here} 
	end
}

rule <object_definition> 
	?!@MemberList members 
	{ 

	${$ 
		select or		
			repeat
				@LValue lvalue = @LValue.default;

				$identifier$ ?let @lstring key $:$ <value_definition> !?lvalue 

				members += !@Member.new{!key.string !lvalue}
			while
			$,$
			end
		end
	$}$ 
}

rule <value_definition> 
	?!@LValue lvalue 
	{

	select
		$integer$ ?let @luint value
		lvalue = @IntegerLV.new{!@location.here !value.uint} 
	or
		$real$ ?let @ldouble value
		lvalue = @DoubleLV.new{!@location.here !value.double} 
	or
		$'char'$ ?let @lchar value
		lvalue = @CharLV.new{!@location.here !value.char}
	or
		$"string"$ ?let @lstring value
		lvalue = @StringLV.new{!@location.here !value.string} 
	or 
		@lbool value = .default
		<bool_definition> !? value 
		lvalue = @BoolLV.new{!@location.here !value.bool}
	or 
		@LValueList items = {};
		<array_definition>  !?items
		lvalue = @ArrayLV.new{!@location.here !items} 
	or
		@MemberList members = {};
		<object_definition> !?members
		lvalue = @ObjectLV.new{!@location.here !members} 
	end
}

rule <array_definition> 
	?!@LValueList items 
	{

	$[$
	select or  
		repeat
			@LValue lvalue = @LValue.default;
			<value_definition> !? lvalue 
			items += !lvalue;
		while
		$,$
		end
	end
	$]$
}

}

#------------------------------------------------------------
#	S E M A N T I Q U E   -   F U N C T I O N S
#------------------------------------------------------------
method @LValue toString 
	?!@string valuesStr
	{

	@LocalError erreur = {};
	@string ErrorObjectValueNotAllowed = "ObjectValueNotAllowed";
	@string ErrorArrayValueNotAllowed = "ArrayValueNotAllowed";
	[!? erreur insertKey !.new{!ErrorObjectValueNotAllowed !@location.here}]
	[!? erreur insertKey !.new{!ErrorArrayValueNotAllowed !@location.here}]

	if( self is == @IntegerLV ) then  
		@uint lv = [self as @IntegerLV mLvalue]   
		valuesStr += lv  
	elsif( self is == @DoubleLV ) then  
		@double lv = [self as @DoubleLV mLvalue]   
		valuesStr += lv  
	elsif( self is == @CharLV ) then   
		@char lv = [self as @CharLV mLvalue]   
		valuesStr += "'"+lv+"'"  
	elsif( self is == @StringLV ) then   
		@string lv = [self as @StringLV mLvalue]   
		valuesStr += "\""+lv+"\""  
	elsif( self is == @BoolLV ) then   
		@bool lv = [self as @BoolLV mLvalue]   
		if( lv == true ) then 
			valuesStr += '1';
		else
			valuesStr += '0';
		end
	elsif( self is == @ObjectLV ) then
		[!? erreur insertKey !.new{!ErrorObjectValueNotAllowed !@location.here}] 
	elsif( self is == @ArrayLV ) then
		[!? erreur insertKey !.new{!ErrorArrayValueNotAllowed !@location.here}] 
	end
}

method @LValue isPrimitive
	?! @bool isprimitive
	{

	isprimitive = false;

	if( (self is == @IntegerLV) || (self is == @DoubleLV) 
	|| (self is == @CharLV )
	|| (self is == @StringLV )
	|| (self is == @BoolLV) ) then   
		isprimitive = true;  
	end
}

func isPrimitive 
	? @string typeName
	-> @bool isit {

	isit = false;
	
	if( 
		typeName == "Int" 
		|| typeName == "Real" 
		|| typeName == "Char" 
		|| typeName == "String" 
		|| typeName == "Bool" 
	) then
		isit = true;
	end

	
}
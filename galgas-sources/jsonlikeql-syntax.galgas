syntax jsonlikeql_syntax (jsonlikeql_lexique) {

rule <start_symbol> {

	@ClassMap classMap = {};

	@CandidateClassMap candidateClassMap = {};

	@FunctionsMap functionsMap = {};

	@QueryMap queryMap = {};

	# Class du système

	@Class c = .new{!@lstring.new{!"____Application" !@location.here} !{}}
	[!?classMap insertKey ![c name] !c]

	$types$	
	repeat
	while
		@Class aclass = .default
		<class> !? aclass !? candidateClassMap  
	
		[!?classMap insertKey ![aclass name] !aclass]
	end  

	checkCandidateClass(!candidateClassMap !classMap) 

	$functions$ ${$ 	
	repeat
	while 
		<functions_container> !? functionsMap 
	end
	$}$ 

	$queries$ ${$ 	
	repeat
	while
		<queries_container> !? queryMap !? functionsMap
	end
	$}$ 

	@string queries = @string.default;
	for () in queryMap do  
		@string sql = "";
		[query toSql !? sql]
		queries += sql;

		#queries += toSql(![requete functionName] ![requete mParameters] ![requete mResponseFields] !listeDesFonctions) 
	 
	end

	let @string sourceFilePath = @string.stringWithSourceFilePath
	let @string code = [filewrapper generationTemplate.sql
	!queries
	]
	[code writeToFile ![sourceFilePath stringByDeletingPathExtension] + ".sql"]

}


}

filewrapper generationTemplate in "." {
}{
}{
	template sql "jsonlikeql-sql.galgasTemplate" 
	?@string queries 
}

# this function checks if all the candidate class have been declared
proc checkCandidateClass
	?@CandidateClassMap candidateClassMap
	?@ClassMap classMap 
	{

	for () in candidateClassMap	do 
		@lstring candidate = lkey 
 
		if( [[candidate string] length] > 0) then
			# on supprime la clé de la liste des clés candidates
			[!?candidateClassMap removeKey !candidate ] 	
 			
 			# on vérifie que la clé candidate est une classe définie
			[classMap searchKey !candidate ?* ] 
		end
	end 
}
